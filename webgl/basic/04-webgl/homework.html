<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>
            04-GPU与渲染管线：如何用WebGL绘制最简单的几何图形？-课后练习
        </title>
        <style>
            body {
                padding: 0;
                margin: 0;
            }
            #canvas {
                /* width: 512px;
        height: 512px; */
                border: 0.5px dotted #cccccc;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas" width="200" height="200"></canvas>

        <script>
            // 创建 正n边形 顶点数据
            // （中心点x轴坐标，中心点y轴坐标，半径，边条数）
            function createPolygonVertex(x, y, r, n) {
                const sin = Math.sin; // 正弦
                const cos = Math.cos; // 余弦
                const perAngel = (2 * Math.PI) / n; // 360° / n
                const positionArray = []; // 位置信息
                for (let i = 0; i < n; i++) {
                    const angel = i * perAngel;
                    const nx = x + r * cos(angel);
                    const ny = y + r * sin(angel);
                    positionArray.push(nx, ny);
                }
                console.log(positionArray);
                return new Float32Array(positionArray);
            }

            // 创建 正n角星 顶点数据
            // （中心点x轴坐标，中心点y轴坐标，小圆半径，大圆半径，边条数）
            function createMultiAngleVertex(x, y, r, R, n) {
                const sin = Math.sin;
                const cos = Math.cos;
                const perAngel = Math.PI / n;
                const positionArray = [];
                for (let i = 0; i < 2 * n; i++) {
                    const angel = i * perAngel;
                    if (i % 2 !== 0) {
                        // 外角顶点
                        const Rx = x + R * cos(angel);
                        const Ry = y + R * sin(angel);
                        positionArray.push(Rx, Ry);
                    } else {
                        // 内角顶点
                        const rx = x + r * cos(angel);
                        const ry = y + r * sin(angel);
                        positionArray.push(rx, ry);
                    }
                }
                console.log(positionArray);
                return new Float32Array(positionArray);
            }
        </script>
        <script>
            /*

                Math.sin(0) = 0
                Math.cos(0) = 1

            */
        </script>

        <script>
            const container = document.getElementById("canvas");
            const gl = canvas.getContext("webgl");

            // 顶点着色器（Vertex Shader）
            // 顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点的信息。
            const vertex = `
            attribute vec2 position;
            varying vec3 color;

            void main() {
                gl_PointSize = 1.0;
                color = vec3(0.5 + position, 0.0);
                gl_Position = vec4(position, 1.0, 1.0);
            }
        `;

            // 片元着色器（Fragment Shader）
            // 片元着色器的作用，就是处理光栅化后的像素信息。
            // 无论有多少个像素点，片元着色器都可以同时处理
            const fragment = `
            precision mediump float;
            varying vec3 color;

            void main()
            {
                gl_FragColor = vec4(color, 1.0);
            }    
        `;

            /*
                创建 webgl 程序
            */
            // 创建 shader 对象
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertex);
            gl.compileShader(vertexShader);
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragment);
            gl.compileShader(fragmentShader);

            // 创建 WebGLProgram 对象，将 shader 关联到 webgl 程序
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            // 启用 WebGLProgram 对象
            gl.useProgram(program);

            /*
                将数据存入缓冲区，也就是将数据送入 GPU
            */

            // const points = new Float32Array([-1, -1, 0, 1, 1, -1]);
            // const points = createPolygonVertex(0, 0, 1, 3) // 正三角形
            // const points = createPolygonVertex(0, 0, 1, 4) // 正方形
            // const points = createPolygonVertex(0, 0, 1, 8) // 正八边形
            // const points = createPolygonVertex(0, 0, 1, 100) // 圆形（接近）

            // const points = createMultiAngleVertex(0, 0, 1, 0.5, 3) // 三角形
            // const points = createMultiAngleVertex(0, 0, 1, 0.5, 4) // 四角形
            // const points = createMultiAngleVertex(0, 0, 1, 0.5, 5) // 五角形
            const points = createMultiAngleVertex(0, 0, 1, 0.9, 100); // 100角形

            // 将定义好的数据写入 WebGL 的缓冲区
            const bufferId = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);
            gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);

            /*
            将缓冲区数据读取到 GPU
        */
            const vPosition = gl.getAttribLocation(program, "position"); // 获取顶点着色器中的position变量的地址
            gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0); // 给变量设置长度和类型
            gl.enableVertexAttribArray(vPosition); // 激活这个变量

            /*
            执行着色器程序完成绘制
        */
            gl.clear(gl.COLOR_BUFFER_BIT); // 画布清除

            // 绘制模式（绘制图元的方式， 起始点， 绘制点数）
            // gl.drawArrays(gl.TRIANGLES, 0, points.length / 2); // 绘制实心三角形
            gl.drawArrays(gl.LINE_LOOP, 0, points.length / 2); // 绘制线圈（空心）
            // gl.drawArrays(gl.TRIANGLE_STRIP, 0, points.length / 2); // 绘制三角带（实心）
            // gl.drawArrays(gl.LINE_STRIP, 0, points.length / 2); // 绘制线条
        </script>
    </body>
</html>
