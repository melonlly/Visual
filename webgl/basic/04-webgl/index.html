<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>04-GPU与渲染管线：如何用WebGL绘制最简单的几何图形？</title>
        <style>
            body {
                padding: 0;
                margin: 0;
            }
            #canvas {
                /* width: 512px;
            height: 512px; */
                border: 0.5px dotted #cccccc;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas" width="200" height="200"></canvas>

        <script>
            const container = document.getElementById("canvas");
            const gl = container.getContext("webgl");

            // 顶点着色器（Vertex Shader）
            // 顶点着色器理解为处理顶点的 GPU 程序代码。它可以改变顶点的信息。
            const vertex = `
                attribute vec2 position;
                varying vec3 color;

                void main() {
                    gl_PointSize = 1.0;
                    color = vec3(0.5 + position, 0.0);
                    gl_Position = vec4(position, 1.0, 1.0);
                }
            `;
            
            // 片元着色器（Fragment Shader）
            // 片元着色器的作用，就是处理光栅化后的像素信息。
            // 无论有多少个像素点，片元着色器都可以同时处理
            const fragment = `
                precision mediump float;
                varying vec3 color;

                void main()
                {
                    gl_FragColor = vec4(color, 1.0);
                }    
            `;

            /*
                创建 webgl 程序
            */
            // 创建 shader 对象
            const vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertex);
            gl.compileShader(vertexShader);
            const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragment);
            gl.compileShader(fragmentShader);
            
            // 创建 WebGLProgram 对象，将 shader 关联到 webgl 程序
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            // 启用 WebGLProgram 对象
            gl.useProgram(program);

            /*
                将数据存入缓冲区，也就是将数据送入 GPU
            */
            const points = new Float32Array([
                -1, -1,
                0, 1,
                1, -1,
            ]);
            // 创建并初始化一个用于储存顶点数据或着色数据的 WebGLBuffer 对象
            const bufferId = gl.createBuffer();
            /*
                将给定的WebGLBuffer绑定到目标
                void gl.bindBuffer(target, buffer);
                    target
                        gl.ARRAY_BUFFER: 包含顶点属性的Buffer，如顶点坐标，纹理坐标数据或顶点颜色数据
                        gl.ELEMENT_ARRAY_BUFFER: 用于元素索引的Buffer
                    buffer      要绑定的 WebGLBuffer
            */
            gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);
            /*
                创建并初始化了Buffer对象的数据存储区
                void gl.bufferData(target, ArrayBufferView srcData, usage, srcOffset, length);
                    target
                        gl.ARRAY_BUFFER: 包含顶点属性的Buffer，如顶点坐标，纹理坐标数据或顶点颜色数据
                        gl.ELEMENT_ARRAY_BUFFER: 用于元素索引的Buffer
                    srcData     数组对象，将被复制到Buffer的数据存储区
                    usage       指定数据存储区的使用方法
                        gl.STATIC_DRAW: 缓冲区的内容可能经常使用，而不会经常更改。内容被写入缓冲区，但不被读取
                        gl.DYNAMIC_DRAW: 缓冲区的内容可能经常被使用，并且经常更改。内容被写入缓冲区，但不被读取
                        gl.STREAM_DRAW: 缓冲区的内容可能不会经常使用。内容被写入缓冲区，但不被读取
                        gl.STATIC_READ 、 gl.DYNAMIC_READ 、 gl.STREAM_READ 、 gl.STATIC_COPY 、 gl.DYNAMIC_COPY 、 gl.STREAM_COPY
                    srcOffset   指定读取缓冲时的初始元素索引偏移量
                    length      0
            */
            gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
            
            /*
                将缓冲区数据读取到 GPU
            */
            const vPosition = gl.getAttribLocation(program, 'position'); // 获取顶点着色器中的position变量的地址
            /*
                void gl.vertexAttribPointer(index, size, type, normalized, stride, offset)
                    index       指定要修改的顶点属性的索引
                    size        指定每个顶点属性的组成数量，必须是1，2，3或4
                    type        指定数组中每个元素的数据类型
                    normalized  当转换为浮点数时是否应该将整数数值归一化到特定的范围
                    stride      以字节为单位指定连续顶点属性开始之间的偏移量
                    offset      指定顶点属性数组中第一部分的字节偏移量
            */
            gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0); // 给变量设置长度和类型
            gl.enableVertexAttribArray(vPosition); // 打开属性数组列表中 指定索引 处的通用顶点属性数组

            /*
                执行着色器程序完成绘制
            */
            gl.clear(gl.COLOR_BUFFER_BIT); // 画布清除

            // 绘制模式（绘制图元的方式， 起始点， 绘制点数）
            // gl.drawArrays(gl.TRIANGLES, 0, points.length / 2); // 绘制实心三角形
            gl.drawArrays(gl.LINE_LOOP, 0, points.length / 2); // 绘制线圈（空心）
            // gl.drawArrays(gl.TRIANGLE_STRIP, 0, points.length / 2); // 绘制三角带（实心）
            // gl.drawArrays(gl.LINE_STRIP, 0, points.length / 2); // 绘制线条

        </script>

        <script>
            /*

                关键字	    数据类型
                vec2	    二维向量，具有xy两个分量，分量是浮点数
                vec3	    三维向量 ，具有xyz三个分量，分量是浮点数
                vec4	    四维向量 ，具有xyzw四个分量，分量是浮点数
                ivec2	    二维向量，分量是整型数
                ivec3	    三维向量 ，分量是整型数
                ivec4	    四维向量 ，分量是整型数
                bvec2	    二维向量，分量是布尔值bool
                bvec3	    三维向量 ，分量是布尔值bool
                bvec4	    四维向量 ，分量是布尔值bool

                关键字	    数据类型
                mat2	    2x2矩阵，4个元素
                mat3	    3x3矩阵，9个元素
                mat4	    4x4矩阵，16个元素

                    mat4 * vec4：矩阵mat4左乘向量vec4，矩阵和向量的乘法运算规则，参考线性代数中矩阵和列向量的乘法运算
                    mx * my：表示矩阵mx左乘矩阵my，着色器中矩阵之间乘法运算规则和线性代数中规则一致
                
                内置变量	        含义	                            值数据类型
                gl_PointSize	    点渲染模式，方形点区域渲染像素大小	    float
                gl_Position	        顶点位置坐标	                      vec4
                gl_FragColor	    片元颜色值	                          vec4
                gl_FragCoord	    片元坐标，单位像素	                   vec2
                gl_PointCoord	    点渲染模式对应点像素坐标	            vec2

                    gl_Position
                        “逐顶点”，在着色器中，如果有多个顶点，可以理解为每个顶点都要执行一遍顶点着色器程序中主函数 main
                    gl_FragColor
                        “逐片元”，顶点经过片元着色器片元化以后，得到一个个片元，或者说像素点，
                            然后通过内置变量gl_FragColor给每一个片元设置颜色值，
                            所有片元可以使用同一个颜色值，也可能不是同一个颜色值，可以通过特定算法计算或者纹理像素采样
                        可以理解为每个片元都要执行一遍片元着色器程序中主函数 main
                
                关键字(变量类型)	数据传递	                        声明变量
                attribute	        javascript——>顶点着色器	            声明顶点数据变量
                uniform	            javascript——>顶点、片元着色器	     声明非顶点数据变量
                varying	            顶点着色器——>片元着色器	             声明需要插值计算的顶点变量

                    varying类型变量主要是为了完成顶点着色器和片元着色器之间的数据传递和插值计算
                        在顶点、片元两个着色器代码中都需要通过关键字 varying 声明一个新变量
                

                顶点着色器代码会在GPU的顶点着色器单元执行  ->  片元  ->   片元着色器代码会在GPU的片元着色器单元执行


                预处理的命令
                    #define
                        宏定义，在编译处理阶段，替换预定义的符号
                    #include
                        引入文件
                            #include <common>
                            引入 common.glsl 文件
                    #ifdef - #endif
                        判断一个宏定义是否存在，如果存在，保留之间的代码
                    ...

            */
        </script>
    </body>
</html>
