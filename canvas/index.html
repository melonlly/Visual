<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>canvas</title>
        <style>
            body {
                padding: 0;
                margin: 0;
            }
            #canvas {
                /* width: 512px;
            height: 512px; */
                border: 0.5px dotted #cccccc;
            }
        </style>

        <script src="../common/d3-hierarchy.v1.min.js"></script>
    </head>
    <body>
        <canvas id="canvas" width="800" height="800"></canvas>

        <script>
            const TAU = 2 * Math.PI;

            function draw(
                ctx,
                node,
                { fillStyle = "rgba(0, 0, 0, 0.2)", textColor = "white" } = {}
            ) {
                const children = node.children;
                const { x, y, r } = node;
                ctx.fillStyle = fillStyle;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, TAU);
                ctx.fill();
                if (children) {
                    for (let i = 0; i < children.length; i++) {
                        draw(ctx, children[i]);
                    }
                } else {
                    const name = node.data.name;
                    ctx.fillStyle = textColor;
                    ctx.font = "1rem Arial";
                    ctx.textAlign = "center";
                    ctx.fillText(name, x, y);
                }
            }

            CanvasRenderingContext2D.prototype.clearCircle = function (x, y,r) {
                context.save();
                context.fillStyle = "rgba(255,255,255,255)";
                context.beginPath();
                context.arc(x, y, r, 0, TAU);
                context.fill();
                context.restore();
            };

            const container = document.getElementById("canvas");
            let context = ''; // 上下文
            let root = ""; // 根节点
            if (container) {
                context = container.getContext("2d");

                const rectSize = [100, 100];
                context.fillStyle = "red";
                context.save(); // 暂存状态
                context.translate(-0.5 * rectSize[0], -0.5 * rectSize[1]); // 平移
                context.beginPath();
                context.rect(
                    0.5 * canvas.width,
                    0.5 * canvas.height,
                    ...rectSize
                );
                context.fill();
                context.restore(); // 恢复状态

                context.clearRect(0, 0, 800, 800); // ---->> 清除画板
                
                const dataSource =
                    "https://s5.ssl.qhres.com/static/b0695e2dd30daa64.json";
                (async function () {
                    const data = await (await fetch(dataSource)).json();

                    // 将省份数据按照包含城市的数量，从多到少排序
                    const regions = d3
                        .hierarchy(data)
                        .sum((d) => 1)
                        .sort((a, b) => b.value - a.value);

                    // 将数据映射为一组 1600 宽高范围内的圆形，在每个相邻的圆之间我们还保留 3 个像素的 padding
                    const pack = d3.pack().size([800, 800]).padding(3);

                    root = pack(regions);
                    console.log(root);

                    // 将数据中的 x、y、r 通过 canvas 绘制出来
                    draw(context, root);

                    // 设置鼠标监听
                    container.addEventListener(
                        "mousemove",
                        ({ clientX, clientY }) => {
                            isInCircle(context, clientX, clientY, root);
                        }
                    );
                })();

                // // 设置鼠标监听
                // window.addEventListener("mousemove", ({ clientX, clientY }) => {
                //     const x = clientX
                //     const y = clientY
                //     // 1.查找距离最近的圆心
                //     // 最近的圆
                //     let closest = {
                //         c: ''
                //     }
                //     findClosest(root, closest, x, y)
                //     // console.log(closest)
                //     // 2.判断是否在距离最近的圆中（到圆心距离是否小于半径）
                //     const t = Math.pow(Math.abs(x - closest.c.x), 2) + Math.pow(Math.abs(y - closest.c.y), 2) // 到圆心距离的平方
                //     if (t <= Math.pow(closest.c.r, 2)) {
                //         console.log(closest.c) // 最近的圆（且在圆中）
                //     } else {
                //         // 3.如果不在，向上查找父级圆，判断是否在父级圆中，依此向上查找

                //     }
                // })
            }

            // 查找最近的圆 (x - rx)^2 + (y - ry)^2 = t^2  -->  想要到圆心距离 t 足够小，则 |x - rx| + |y - ry| 需要足够小
            // function findClosest(root, closest, x, y, t = 800) {
            //     const tan = Math.abs(x - root.x) + Math.abs(y - root.y) // 到圆心距离
            //     if (tan < t) {
            //         t = tan
            //         closest.c = root
            //         if (root.children && root.children.length > 0) {
            //             for (let i = 0; i < root.children.length; i++) {
            //                 findClosest(root.children[i], closest, x, y, t)
            //             }
            //         }
            //     }
            // }

            // 鼠标检测移动到小圆就变色
            function isInCircle(ctx, mx, my, node) {
                const children = node.children;
                if (children) {
                    // 找的最末节点的距离最近的圆
                    for (let i = 0; i < children.length; i++) {
                        isInCircle(ctx, mx, my, children[i]);
                    }
                } else {
                    const { x, y, r } = node;
                    if ((my - y) * (my - y) + (mx - x) * (mx - x) < r * r) {
                        ctx.clearCircle(x, y, r);
                        ctx.fillStyle = "rgba(255,0,0,0.2)";
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, TAU);
                        ctx.fill();
                        const name = node.data.name;
                        ctx.fillStyle = "white";
                        ctx.font = "1.5rem Arial";
                        ctx.textAlign = "center";
                        ctx.fillText(name, x, y);
                    }
                }
            }
        </script>
    </body>
</html>
